/*global $*/
/*jslint unparam: true*/
/*

    Eternal Power Calculator
    Copyright (C) 2018  Matt Kimball

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

*/


'use strict';


/*
    Deck codes are generated by a three step process:

    1.  Generate a list of integer values, with three values for each
        card line in the decklist.
    2.  Translate the list of integers from a list of range [0, infinity]
        to a list of range [0, 63].
    3.  Generate one character for each entry in the list from step 2.

    Set one happens in epc-deck.js, but steps two and three are below.

    For step one, triples are generated as
    [ card-count, set-number, card-number ].

        4 Grenadin Drone (Set1 #5)
        4 Champion of Fury (Set2 #187)

    becomes [ 4, 1, 5, 4, 2, 187 ].

    For step two, the values from step one are encoded as 5-bit values
    with the 6th bit indicating whether the value is continued in
    the next character.  The values are stored in little endian order.

    [ 4, 1, 5, 4, 2, 187 ] becomes [ 4, 1, 5, 4, 2, 59, 5 ].
    Note that (59 & 31) + 5 * 32 = 187.

    In the third step, the characters are generated for each value from
    step two using the following table:

        0-25: 'A'-'Z'
        26-51: 'a'-'z'
        52-61: '0'-'9'
        62: '-'
        63: '_'

    This is similar to uuencode.  uuencode is not used as-is
    because uuencode can generate characters which are not URL-safe.
*/



/*
    Encode a list of values in range [0, infinity] into a
    URL-safe code.
*/
function encodeValues(
    values
) {
    var code, error;

    code = '';
    $.each(values, function (index, i) {
        var r;

        if (error) {
            return;
        }

        if (i < 0) {
            error = "negative value";
            return;
        }

        if (i === 0) {
            code = code + "A";
        }

        while (i > 0) {
            r = i % 32;
            i = (i - r) / 32;

            if (i > 0) {
                r = r + 32;
            }

            if (r < 26) {
                code = code + String.fromCharCode(65 + r);
            } else if (r < 52) {
                code = code + String.fromCharCode(97 + r - 26);
            } else if (r < 62) {
                code = code + String.fromCharCode(48 + r - 52);
            } else if (r === 62) {
                code = code + '-';
            } else if (r === 63) {
                code = code + '_';
            }
        }
    });

    if (error) {
        return null;
    }

    return code;
}


/*  Decode a URL-safe code into a list of values.  */
function decodeValues(
    code
) {
    var values, ix, i, m, r, c, charCode;

    values = [];
    i = 0;  /*  Accumulate starting from zero  */
    m = 1;  /*  Start with an identity multiplier for the first character
                of a value  */

    for (ix = 0; ix < code.length; ix += 1) {
        c = code[ix];

        if (c === '-') {
            r = 62;
        } else if (c === '_') {
            r = 63;
        } else {
            charCode = c.charCodeAt(0);

            if (charCode >= 97) {
                r = charCode - 97 + 26;
            } else if (charCode >= 65) {
                r = charCode - 65;
            } else {
                r = charCode - 48 + 52;
            }
        }

        /*  Is this value carried to the next character?  */
        if (r >= 32) {
            i = i + m * (r % 32);
            m = m * 32;
        } else {
            i = i + m * r;
            values.push(i);

            i = 0;
            m = 1;
        }
    }

    if (m !== 1) {
        return null;
    }

    return values;
}


/*
    Test encoding/decoding by encoding a value list and decoding
    it back, and then comparing the starting and resulting lists
    to ensure they are the same.
*/
function testEncode() {
    function testValueSet(values) {
        var e, d, ix;

        e = encodeValues(values);
        d = decodeValues(e);

        console.assert(values.length === d.length);
        for (ix = 0; ix < values.length; ix += 1) {
            console.assert(values[ix] === d[ix]);
        }
    }

    testValueSet([3, 2, 1]);
    testValueSet([32, 33, 64, 65, 1024, 1025]);
    testValueSet([31, 63, 127, 255]);
    testValueSet([30, 62, 126, 254]);

    console.assert(encodeValues([ -1 ]) === null);
}
